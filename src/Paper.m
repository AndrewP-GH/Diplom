clearvars; clc; close all;
Figure = NewFigure('Бумага');
hold all;
grid on;
%% Params
global FormatStr        %формат вывода времени на графике
FormatStr = '%.3f';
V_0 = 1;                %продольная скорость движения пластины
C = sqrt(2);            %C - скорость распространения волны
V_C = V_0^2 - C^2;      
dx = 0.01;              %h - шаг по длинне
dt = 0.01;              %tau - шаг по времени
L_x = 1;                %длинна между роликами
S = L_x;                %? - длина пластины(абсолютная?)
Ro = 1;                 %плотность материала пластины
m = Ro*S;               %масса на единицу длины пластины
T_0 = 1;                %продольное напряжение пластины (на единицу длины)

T = 1;                  %время (верхняя граница)

X = 0:dx:L_x;           %сетка по длине пластины
Nx = size(X, 2);        %число узлов в сетке X
g_max = 1;              %max управляющей функции
g_max = g_max/m;
val_g = 0;              %начальное управление
g = @(t, val) 0;        %управляющая функция

%% Решение задачи
axis([0 L_x -0.5 0.5]);

p_0 = 0.2*sin(pi*X);	%начальное распределение точек листа
p_1 = zeros(1,Nx);      %начальное распределение скорости листа
L = zeros(2,2,Nx);      %прогоночные коэффициенты
M = zeros(2,1,Nx);      %прогоночные коэффициенты
P = [p_0; p_1];         %векторзначений (W, V)
P(:,1) = 0;             %граничное левое
P(:,Nx) = 0;            %граничное правое

A_i =   [   0 0; 
            V_C*dt -V_0*dt*dx
        ];
B_i =   [   1 -dt;
            -2*V_C*dt dx^2
        ];
C_i =   [   0 0; 
            V_C*dt V_0*dt*dx
        ];
    
L(:,:,3) = - B_i \ C_i;
for i = 4:Nx
    L(:,:,i) = -(A_i * L(:,:,i-1) + B_i) \ C_i;
end

plot(0,0, 'w');     %для отображения времени в легенде

%% Вычисление прямой задачи
p_1 = plot(X,P(1,:));
p_1.LineWidth = 3;
p_2 = plot(X,P(2,:));
Min = 0; Max = 0;
[Min, Max] = LocalExtrems(P, Min, Max);
Legend(0, 'W', 'V');

for t = 0:dt:T-dt
    F = [   P(1,:); 
            dx^2 * (P(2,:) + dt * g(t,0))
        ];
    M(:,:,3) = B_i \ F(:,2);
    for i = 4:Nx
        M(:,:,i) = -(A_i * L(:,:,i-1) + B_i) \ (A_i * M(:,:,i-1) - F(:,i-1));
    end
    for i = Nx-1:-1:2
        P(:,i) = L(:,:,i+1) * P(:,i+1) + M(:,:,i+1);
    end
    p_1.YData = P(1,:);
    p_2.YData = P(2,:);
    drawnow;
    Legend(t+dt, 'W', 'V');
    [Min, Max] = LocalExtrems(P, Min, Max);
end

%% Вычисление обратной задачи
